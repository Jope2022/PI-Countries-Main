{"ast":null,"code":"import ActionTypes from './utils/actionTypes';\nimport warning from './utils/warning';\nimport isPlainObject from './utils/isPlainObject';\nimport { kindOf } from './utils/kindOf';\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  const reducerKeys = Object.keys(reducers);\n  const argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n  if (!isPlainObject(inputState)) {\n    return `The ${argumentName} has unexpected type of \"${kindOf(inputState)}\". Expected argument to be an object with the following ` + `keys: \"${reducerKeys.join('\", \"')}\"`;\n  }\n  const unexpectedKeys = Object.keys(inputState).filter(key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);\n  unexpectedKeys.forEach(key => {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n  if (unexpectedKeys.length > 0) {\n    return `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` + `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` + `Expected to find one of the known reducer keys instead: ` + `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`;\n  }\n}\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key];\n    const initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n    if (typeof initialState === 'undefined') {\n      throw new Error(`The slice reducer for key \"${key}\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.`);\n    }\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === 'undefined') {\n      throw new Error(`The slice reducer for key \"${key}\" returned undefined when probed with a random type. ` + `Don't try to handle '${ActionTypes.INIT}' or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.`);\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nexport default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`);\n      }\n    }\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n\n  // This is used to make sure we don't warn about the same\n  // keys multiple times.\n  let unexpectedKeyCache;\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n  let shapeAssertionError;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n  return function combination() {\n    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let action = arguments.length > 1 ? arguments[1] : undefined;\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        const actionType = action && action.type;\n        throw new Error(`When called with an action of type ${actionType ? `\"${String(actionType)}\"` : '(unknown type)'}, the slice reducer for key \"${key}\" returned undefined. ` + `To ignore an action, you must explicitly return the previous state. ` + `If you want this reducer to hold no value, you can return null instead of undefined.`);\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}","map":{"version":3,"names":["ActionTypes","warning","isPlainObject","kindOf","getUnexpectedStateShapeWarningMessage","inputState","reducers","action","unexpectedKeyCache","reducerKeys","Object","keys","argumentName","type","INIT","length","join","unexpectedKeys","filter","key","hasOwnProperty","forEach","REPLACE","assertReducerShape","reducer","initialState","undefined","Error","PROBE_UNKNOWN_ACTION","combineReducers","finalReducers","i","process","env","NODE_ENV","finalReducerKeys","shapeAssertionError","e","combination","state","arguments","warningMessage","hasChanged","nextState","previousStateForKey","nextStateForKey","actionType","String"],"sources":["C:/Users/jopep/Desktop/PI-Countries-Main/PI-Countries-main/client/node_modules/redux/src/combineReducers.js"],"sourcesContent":["import ActionTypes from './utils/actionTypes'\nimport warning from './utils/warning'\nimport isPlainObject from './utils/isPlainObject'\nimport { kindOf } from './utils/kindOf'\n\nfunction getUnexpectedStateShapeWarningMessage(\n  inputState,\n  reducers,\n  action,\n  unexpectedKeyCache\n) {\n  const reducerKeys = Object.keys(reducers)\n  const argumentName =\n    action && action.type === ActionTypes.INIT\n      ? 'preloadedState argument passed to createStore'\n      : 'previous state received by the reducer'\n\n  if (reducerKeys.length === 0) {\n    return (\n      'Store does not have a valid reducer. Make sure the argument passed ' +\n      'to combineReducers is an object whose values are reducers.'\n    )\n  }\n\n  if (!isPlainObject(inputState)) {\n    return (\n      `The ${argumentName} has unexpected type of \"${kindOf(\n        inputState\n      )}\". Expected argument to be an object with the following ` +\n      `keys: \"${reducerKeys.join('\", \"')}\"`\n    )\n  }\n\n  const unexpectedKeys = Object.keys(inputState).filter(\n    (key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]\n  )\n\n  unexpectedKeys.forEach((key) => {\n    unexpectedKeyCache[key] = true\n  })\n\n  if (action && action.type === ActionTypes.REPLACE) return\n\n  if (unexpectedKeys.length > 0) {\n    return (\n      `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` +\n      `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` +\n      `Expected to find one of the known reducer keys instead: ` +\n      `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`\n    )\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach((key) => {\n    const reducer = reducers[key]\n    const initialState = reducer(undefined, { type: ActionTypes.INIT })\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(\n        `The slice reducer for key \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don't want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      )\n    }\n\n    if (\n      typeof reducer(undefined, {\n        type: ActionTypes.PROBE_UNKNOWN_ACTION(),\n      }) === 'undefined'\n    ) {\n      throw new Error(\n        `The slice reducer for key \"${key}\" returned undefined when probed with a random type. ` +\n          `Don't try to handle '${ActionTypes.INIT}' or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      )\n    }\n  })\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nexport default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // This is used to make sure we don't warn about the same\n  // keys multiple times.\n  let unexpectedKeyCache\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {}\n  }\n\n  let shapeAssertionError\n  try {\n    assertReducerShape(finalReducers)\n  } catch (e) {\n    shapeAssertionError = e\n  }\n\n  return function combination(state = {}, action) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      )\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === 'undefined') {\n        const actionType = action && action.type\n        throw new Error(\n          `When called with an action of type ${\n            actionType ? `\"${String(actionType)}\"` : '(unknown type)'\n          }, the slice reducer for key \"${key}\" returned undefined. ` +\n            `To ignore an action, you must explicitly return the previous state. ` +\n            `If you want this reducer to hold no value, you can return null instead of undefined.`\n        )\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    hasChanged =\n      hasChanged || finalReducerKeys.length !== Object.keys(state).length\n    return hasChanged ? nextState : state\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}